p131
flex 弹性盒子
<a href="/html_css/code_css/code/flex/p131.html"></a>
    /*flex 弹性盒子
    flex(弹性盒， 伸缩盒)
        是css中又一种布局手段， 它主要用于代替浮动来完成页面的布局。
        之前我们用浮动， 浮动主要目的就是让元素可以横着排列， 但是浮动会带来很多问题： 脱离了文档流 还有高度塌陷， 还要清除浮动， 等等， 
        flex 就在css3中为了解决这些问题 做出来的代替浮动的技术   用了flex的可以不用浮动了， 
        flex 可以使元素具有弹性， 让元素可以跟随页面的大小的改变而改变。
        非常的牛逼
    
    flex 可以使元素具有弹性， 让元素可以跟随页面的大小的改变而改变。 
    弹性容器 ：
        要使用弹性盒 ，必须先将一个元素设置为弹性容器。 
        我们通过dispaly： 来设置弹性容器。 
            display: flex, 设置为块级弹性容器。 
            display: flex-inline ，设置为行内弹性容器。 
            不同就是块级独占一行， 行内不独占一行， 就这么个区别 。 
    弹性元素：
        弹性容器的子元素是弹性元素，（弹性项） ， 子元素是，但是子元素的子元素就不是了， 
        弹性元素可以同时弹性容器和弹性元素， 就是它的父元素设置了flex ， 它本身也可以设置flex 不冲突；

    跟flex有关的属性都要分给弹性容器设置的还是给弹性元素设置的： 
    弹性容器的属性： 
        flex-direction 给容器设置的, 指定容器中弹性元素的排列方式
            可选值： 
                row 默认值， 弹性元素在容器中水平排列（左向右）
                row-reverse 弹性元素在容器中反向水平排列（右向左）
                column 弹性元素在容器纵向排列 （上向下）
                column-reverse 弹性元素在容器中纵向反向排列 （下向上）
        弹性容器还有两个概念： 
            主轴； 弹性元素的排列方向称为主轴， 
            侧轴： 与主轴垂直方向的称为侧轴。
    



    弹性元素的属性：
        flex-grow ,指定弹性元素的伸展的系数，
        当父元素有多余空间时， 子元素如何伸展
        父元素的剩余空间， 会按照比例进行分配
        默认值是 0 ， 不伸展，  
        不为1时， 为子元素们的伸展比例。每个子元素的伸展份数。
        值越大， 就越比兄弟元素伸展的多， 有比例的。  

        flex-shrink 指定弹性元素的收缩系数， 
        当父元素中的空间不足以容纳子元素的时候
        默认值是 1 ，  等比例收缩。
        为0 时， 不收缩。
        值越大， 就越比兄弟元素 收缩的多， 有比例的。 

    */



p132
flex 会弹的导航条
<a href="/html_css/code_css/code/flex/p132.html"></a>



p133
<a href="/html_css/code_css/code/flex/p133.html"></a>
<a href="/html_css/code_css/code/flex/p133-2.html"></a>
/*flex 弹性盒子
弹性容器属性： 
    flex-wrap：
        设置弹性元素是否在弹性容器中自动换行。 
        可选值： 
            nowrap 默认值， 元素不会自动换行。 
            wrap 元素沿着辅轴方向自动换行。 
            wrap-reverse; 元素沿着辅轴反方向换行。
    flex-flow:
        wrap 和 direction 的简写属性
        可以这么写： row , wrap，  从左到右排列， 并且自动换行。
    justity-content:
        如何分配主轴上的空白空间（主轴上的元素如何来排列）
        可选值： 
            flex-start 元素沿着主轴起边排列。 
            flex-end 元素沿着主轴终边排列。 
            center 元素居中排列。
            space-around 空白分布到元素两侧。
            space-between 空白均匀分布到元素间。 
            space-eyenly 空白分布到元素的单侧。 

    align-items： 
        元素在辅轴上的如何对齐 设置的是元素之间的对齐方式。
        说的是flex子项在当前行中 辅轴上如何对齐， （如果主轴是从左到右的话，那么说的就是元素在垂直方向的对齐方式）
        可选值：
            stretch: 默认值 ， 将同一行的元素的高度设置为相同的值。
            flex-start 元素不会拉伸，沿着辅轴起边(辅轴的起点)对齐。 
            flex-end 元素不会拉伸， 沿着辅轴终边对齐。
            center 不拉伸， 在辅轴中间对齐。 
            baseline 基线对齐， 在同一行中沿着文字的基线对齐。 
    
    align-content：
        辅轴空白空间的分布，（主轴的空白空间分布是 justity-content）
        可选值 和 justity-content 一样。 都一个意思。 



弹性元素的属性
     align-self: flex-end;
     用来覆盖当前弹性元素上的 align-items 的


justity....都是设置主轴的 
align....  都是设置辅轴的
*/

p134
<a href="/html_css/code_css/code/flex/p134.html"></a>
弹性元素的样式

/*flex 弹性盒子
弹性元素的属性： 
    flex-grow : 弹性增长系数， 
        当父元素还有空隙的时候， 根据这个的比例去拉伸元素
    flex-shrink： 弹性缩减系数， 
        当父元素装不下子元素的时候， 根据这个的比例去压缩子元素。 
            缩减系数的计算方式比较复杂， 
            缩减多少是根据缩减系数和元素大小来计算的， 基本上就是元素越大， 缩减的越多。 
    flex-basis： 元素的基础长度， 设置了这个， 那元素原来多长就没有用了， 
        它指定的是元素在主轴上的基础长度， 
        如果主轴是横向的，则 该值指定的就是元素的宽度， 
        如果主轴是纵向的，则 该值指定的就是元素的高度。 
            他的默认值是auto， 表示的是参考元素自身的高度或宽度。 
    这三个属性就相当于 弹簧的静止时长度（flex-basis）， 和拉伸弹性（flex-grow）， 和压缩弹性（flex-shrink）。 

    flex: 这是一个简写属性， 可以指定一个子元素的这三个样式。
        flex: grow shrink basis;
        例如： flex: 1 1 auto;
            说的是 增长为1 缩减为1 基础长度为auto;
        这个值也有可选值： 
            initial ===  flex :0 1 auto;
            auto    ===  flex :1 1 auto;
            none    ===  flex :0 0 auto;  这种的话， 弹性元素没有弹性了就。 
    order: 指定子元素的顺序， order越小， 越在前

*/



p135
淘宝导航的一个练习页面，
<a href="/html_css/code_css/code/flex/p135.html"></a>
体会： 
    在和屏幕大小有关的样式中 可以用父元素百分比的方式，定义子元素， 这样的话就会按着屏幕大小来变化子元素的宽度了。




p136
聊聊像素
<a href="/html_css/code_css/code/flex/p136.html"></a>
/* 聊聊像素
我们学过的这些可不可以写写移动端的样式了呢 ？

先说说像素： 
    像素： 
        屏幕是由一个一个发光的小点构成的，这小点， 就是像素， 
        电脑的分辨率 说的就是 电脑屏幕上的小点的数量。 
        在前端开发中像素分成两种情况： css像素， 和物理像素。
        css像素， 就是编写网页时我们用的就是css像素。
            浏览器在显示网页时，需要将css像素转换为物理像素然后再呈现。
            一个css像素最终由几个物理像素显示， 是由浏览器决定的。
            默认情况下在pc端，一个css像素 = 一个物理像素， 
            但是一般不默认
            都是浏览器决定用几个物理像素展示一个像素
            分辨率高就几个物理像素展示一个css像素。

    视口（viewport）
        视口就是屏幕中用来显示网页的区域，
        可以通过查看视口的大小， 来观察css像素和物理像素的比值。
        比如正常情况下 css像素和物理像素比是1:1
        将视口放到200% css像素和物理比值就是 1:2了，
    我们可以通过改变视口的大小， 来改变css像素和物理像素的比值。


*/




p137
<a href="/html_css/code_css/code/flex/p137.html"></a>
/* 移动端  

在不同的屏幕 ， 单位像素的大小是不同的， 像素越小 屏幕就越清晰，
  手机端的像素要远远小于电脑上的， 就像素点多， 高 ， 密
    多是多， 但是手机小啊， 
    iphone6 宽 一共750个像素， 
    但是他能看 css像素宽度为1200px的网页， 
    为什么？ 
    默认情况下， 移动端的网页都会将视口设置为980像素（css像素）
        以确保pc网页可以在移动端正常访问， 
        但是如果网页宽度超过了980 那么移动端浏览器也会自动将网页缩放以完整显示网页。
        这样大部分的pc网页都可以移动端正常浏览， 但是
    但是这种看着不好看，因为
    物理像素有 750个，  却要显示 css像素 980个 
    本来手机上像素就很小了 还要用 一个物理像素展示好几个css像素，
    所以看着网页上的东西就更小了，

    为了解决这个不好看的问题， 大部分网站都会专门为移动端设计网页。



*/


p138
完美视口
<a href="/html_css/code_css/code/flex/p138.html"></a>
/*完美视口
移动端默认的视口大小是 980（css像素）
    默认情况下， 移动端的像素比就是 980 /移动端宽度（iphone6 是750）
    如果我们直接在网页中编写移动端代码， 这样在980的视口下
    像素比是非常不好的， 导致手机网页中的内容会非常非常非常小的。

所以 编写移动页面 必须要确保又一个比较合理的像素比才行。
  1个css 像素  对应多个 物理像素 
  这样出来的东西才不会特别的小。 

怎么找一个比较好的像素比呢？ 
可以通过meta标签来设置视口大小。 
<meta name="viewport" content="width=device-width, initial-scale=1.0">
viewport 就是用来设置视口大小的
content 里面设置  width 是 视口宽度， 我们通过设置这个就能调整 css像素与实际像素的比值。
比如设置个 980 就是  一个css对应一个物理像素， 但是这样会小
设置个 375  375 / 980  就是 完美的 1css : 2物理像素， 
好是好， 但是换个设备就不行了， 
于是 有了这个  width=device-width 
这是浏览器的变量， 设备完美视口的变量， 换设备也能保持完美视口，
initial-scale=1.0 这是定义默认不缩放，


结论： 以后写移动端的页面，
就把上边那个mate标签先写上， 让他是个完美视口在说。
*/


p139
vw单位
<a href="/html_css/code_css/code/flex/p139.html"></a>
/* vw单位 


不同的设备完美视口的大小是不一样的。 
    iphone6 视口大小是 375
    iphone6plus 视口大小是 414 ， 
    这样的话， 比如写一个375px的div, 在iphone6视口是全屏的， 但是在 plus就是少了一块。

    所以在移动端开发的时候， 就不能用 px 来进行布局了，用px的话， 换设备样式就乱了 。

vw 表示的是视口的宽度，（viwwport width）  叫视口宽度。 
  100vw = 一个完美视口的宽度。 
  1vw = 1% 的视口宽度
vw 这个单位永远相当于视口宽度进行计算的。
设计图的宽度：  一般都是 750px  或 1125px
因为默认移动端都默认以为是350的完美视口， 750是2倍图，  1125是3倍图。
如果在设计图上有个 48px * 35px 的一个元素， 我们想搞一个这么大的， 怎么写？ 

根据 100vw = 设计图上的750px  那么 0.133333  = 1px
6.4vw = 48px (设计图像素)
4.6vw = 35px
那这是相当麻烦了， 还得换算 
那就需要 vw适配


*/


p140
vw适配
<a href="/html_css/code_css/code/flex/p140.html"></a>
/*vw适配
        
我们可以 借助 rem来适配 vw ， 
rem 是  跟元素的字体大小，


100vw = 完美视口宽度的话，
下面的px指的都是 设计图上的px, 100vw 指的设备上的屏幕宽度。 
那么在  750px的设计图中，  1px 等于多少vw  ?       100vw / 750 px = 0.133333vw
也就是说  0.1333vw = 1px， 

1rem = 1个字体大小， 
那如果 我们把计算好的0.1333vw(1px) 设置给font-size 那么是不是下面直接写 1rem 就能表示1px了
理论上是可以的。 

那如果 我们要写 48px * 35px 的div 
就直接48rem   35rem 就行了 
但是 实际上发现这样是不行的。 html 的 font-size 设置不上 无效
因为 网页中字体大小最小设置12px 不能设置一个比12像素还小的字体。 
我们的 0.1333333vw 显然是很小了，不行
于是我们得将它扩大到 能用， 
0.1333333 * 40 = 5.33333vw 
这样我们再将 font-size = 5.33333vw， 
这样的话 相当于  1rem = 40px， 
我们再在页面上如果想要一个 48px 的东西， 那么 就用 48 / 40 看它应该用多少个rem显示， 
这样就能达到目的了， 

也可以将font-size设置 3.33333vw 这是 0.133333 的 25倍， 
也就是说 3.3333vw 相当于  设计图25px     
就是说 1rem = 25px, 

font-size 设计多大都行， 只要大于 浏览器承认的大小就行。 

*/


p141  好孕帮手机端首页
<a href="/html_css/code_css/code/flex/haoyunbang_mobile.html"></a>


多行文字的溢出的时候 想让他后面的变省略号

display: -webkit-box;
-webkit-line-clamp: 2;  /*要显示的行数*/
-webkit-box-orient: vertical;
注意 -webkit-line-clamp是webkit的私有属性，是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。
    -webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：
        display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
        -webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。

延伸：单行文本溢出显示省略号...代码
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap


p143
响应式布局。 
<a href="/html_css/code_css/code/flex/p143.html"></a>

/*响应式布局。 
就是网页可以根据不同的设备或窗口大小，呈现出不同的效果。 
这个和纯纯做一个移动端网页不是一样的，  这种还是pc端页面 只是可以根据窗口大小 变换样式的。 
通过响应式布局， 可以使一个网页适用于所有设备。 

响应式布局的关键， 就是 媒体查询， 
通过媒体查询， 可以为不同的设备， 或设备不同状态来分别设置样式。 

怎么用媒体查询呢 ？
    语法：  @media  查询规则{}
    媒体类型： 
        all  所有设备
        print 打印设备，
        screen 带屏幕的设备， 
        speech 屏幕阅读器。 
        可以使用， 连接多个媒体类型， 这样它们之间就是一个或的关系了， 就写上的都可以了；
        也可以这样写， 可以在媒体类型前面加一个only 表示只有。
        @media only screen {}
        写上 only， 可以兼容一些老版本浏览器， 让老版本不用这个样式， 省的出错， only只有新的浏览器认识，

这样就可以为不同的设备设置不同的样式了。

*/

p144
媒体特性
<a href="/html_css/code_css/code/flex/p144.html"></a>

/*媒体特性
除了刚讲的 指定设备的关键字， 
    还有
    width 视口高度
    height 视口宽度

    min-width  视口的最小宽度 ，（视口大于指定）
    max-width  视口的最大宽度 ，（视口小于指定） 
   
样式切换的分界点， 我们称其为断点， 也就是网页的样式 会在这个点时发生变化， 
比如这个例子：   width 500px 就是一个断点。
@media (min-width: 500px){  //大于500宽时使用里面的样式。 
body{
    background-color: cadetblue;
}
}
一般比较常用的断点。

小于768的 超小屏幕     max-width:768px;
大于768的 小屏幕      min-width : 768px;
大于992的屏幕，       min-width : 992px;
大于1200 大屏幕       min-width : 1200px；

不只可以使用一个条件， 
多一个括号就可以多个条件了，比如 想要 大于400 小于500的屏幕使用这个样式， 
但是两个括号中间 ，号的话 两个条件是或的关系
如果用and  连接，  两个条件就是  并且的关系。 

大于400 并且 小于500
@media (min-width: 400px) and (max-width: 500px){
body{
    background-color: cadetblue;
}
}



*/


/* 最完整的就是这样的 带屏幕的，并且  在视口在 400px —— 500px 之间 时使用 里面的样式。 
*/
@media only screen and (min-width: 400px) and (max-width: 500px){
body{
    background-color: cadetblue;
}
}



p145
练习 ， 美图手机导航结构
响应式布局的一个练习。 

<a href="/html_css/code_css/code/flex/p145.html"></a>

自己重新写一遍
<a href="/html_css/code_css/code/flex/p145-2.html"></a>
 